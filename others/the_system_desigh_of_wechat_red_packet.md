原文: [微信高并发资金交易系统设计方案——百亿红包背后的技术支撑](http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2650995437&idx=1&sn=fefff4bff3e183d656a2d242e4c0a382)

首先 ，我觉得本文排版清晰，循序渐进，读来通俗易懂。

具体过程为：介绍背景、业务特点（对比普通秒杀系统）、分析技术难点、分析高并发的常用解决方案的利弊、以及最终的解决方案。

其次从业务上来看，

微信红包这个场景对于大家来说已经非常清晰了，但除了普通的一人对一人的红包，高并发的需求主要来自群红包。 

先将群红包的场景转换为传统业务中的秒杀活动，一个群内发一个红包相当于一个秒杀产品上架，群里的人对这个红包进行秒杀行为。

其次，因为微信红包是对于钱的交易，所以安全级别更高，并且不能出现超卖的现象（发一百元的红包最后不能称为101元）。

然后从技术难点上来看，

主要就是对库存(库存有点像余额)的事务操作。

传统秒杀活动在对库存的操作中，需要经历锁住数据表中表示库存的那一行、扣库存、释放锁的过程。所有的请求都对这一行进行事务（锁）的操作。

但是因为每一个红包都是一次秒杀活动，所以这里演化成了一些请求对某一行进行抢锁，另一些请求对另某一行进行抢锁，也就有大量的抢锁行为在进行。

`但是我个人有点感觉，虽然发生了大量抢锁，但是是对不同行的抢锁行为，会不会没那么严重。可以做一个实验来验证一下。`

下面让我们看看常用解决方案，

1. 扣库存的行为在内存中进行，肯定能提高并发性能。但是一旦机器挂了，内存丢了，数据就丢了。所以还得再加一个异步DB持久化。但是当内存操作成功后，在异步DB持久化之前机器故障了或者异步持久化失败了的话，数据还是有丢的风险。不适合对红包这种对资金操作的业务场景。

1. 用乐观锁替代悲观锁。

	之前说的方案是悲观锁，当拿到了某行悲观锁后，别的事务操作都不能进行，只能等着，等到第一个事务释放悲观锁。

	乐观锁是使用版本号的方式(隐约觉得有点像多版本控制)：多个事务并发进行，先获取数据和版本号，然后处理，当需要提交数据时，会检查该事务读取数据时的版本号与即将提交的版本号是否相同，如果相同则提交，并将版本号+1，不同则表示数据被别的事务修改，立刻回滚。
	
	很显然乐观锁会造成大量回滚、有的用户点击拆红包却有得到了失败的提示等缺点，完全不适用。
	
最后展示最终解决方案，

1. 分而治之，一个一个红包之间无关联。所以对每一个红包设置一个ID，按规则(取模)将此红包分配给一套处理系统处理（包含server和DB）。

   img src="http://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VMyvfdIg148h2Jw2T9b9hNtIV3qQyzhib5bmQVvEpuY07wpxSD850F0X05KvYwGjiaXTGr9Uo5gUr9Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1" width="50%" height="50%">

1. server进行排队控制，解决DB内部的抢锁问题。每一个红包都有一个队列（根据ID可建立），再将拆红包的动作装进自己红包ID的队列，队列按先进先出的规则，串行的操控数据库。

1. 使用memcached的CAS原子累增操作，控制进入DB执行拆红包的事务的请求数，超过阈值则拒绝服务。

1. 对数据库的设计采用了按天和按红包ID的hash值在两个维度上分表。比如表名：db_xx.t_y_dd，xx/y表示hash值后三位，dd表示天数。我怎么觉得直接按日期和xx/y表示hash值后三位分别不久完了么。这样可以解决DB单表数据膨胀、冷热数据分离、备份、数据搬迁的问题。


