<html>
<head>
  <title>BLOG - zhangyang27</title>
  <!-- 新 Bootstrap 核心 CSS 文件 -->
  <link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.css">

  <!-- 可选的Bootstrap主题文件（一般不用引入） -->
  <link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap-theme.min.css">

  <!-- jQuery文件。务必在bootstrap.min.js 之前引入 -->
  <script src="https://cdn.bootcss.com/jquery/1.11.1/jquery.min.js"></script>
  <!-- 最新的 Bootstrap 核心 JavaScript 文件 -->
  <script src="https://cdn.bootcss.com/bootstrap/3.3.0/js/bootstrap.min.js"></script>

	<script src="https://cdn.bootcss.com/highlight.js/9.8.0/highlight.min.js"></script>
	<link href="https://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css" rel="stylesheet">
  <script>hljs.initHighlightingOnLoad();</script>
</head>

<body style="padding: 20px;">
<h2>代理模式(proxy_pattern)<small>2017-01-28 11:32:00</small></h2>
<p>
编码了这么多，觉得设计模式越发重要，所以再总结下。</br>
wiki上已经总计的很好了：<a href="https://en.wikipedia.org/wiki/Proxy_pattern">代理模式</a>
</p>
<h4>
	基本含义
</h4>
如图所示，实际上客户端对RealSubject有请求，但是代理模式要求客户端只能请求Proxy对象，Proxy对象再以委派的方式调用RealSubject，RealSubject将结果返回给Proxy对象，Proxy对象再将结果返回给客户端。
为了方便客户端访问，Proxy对象和RealSubject对象保持相同的方法：DoAction()，所以他们都有个共同的接口Subject。
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/75/Proxy_pattern_diagram.svg/439px-Proxy_pattern_diagram.svg.png">
<h4>
	使用场景
</h4>

<p>
代理模式似乎使得访问流程变得冗余了，但有也有好处：在代理中添加额外的逻辑、功能，使整个系统更好的工作。
</p>
<p>
比如在现实生活中，如果一个老板非常忙，就会请一个秘书，要找老板的人会先找秘书：秘书可能会直接替老板回答一些问题、回绝一些想见老板的人等等，但当秘书真做不了决定时，他会再去请问老板，老板把答案告诉秘书，秘书再告诉别人。
</p>
<p>
在这里，我认为秘书就充当了代理。为老板节约了时间，有一种过滤的作用。
</p>
<p>
生活中也有不得不使用代理的情况：与外国人交流时，请个翻译。翻译在这里就是充当了代理的角色。
</p>
<div>
计算的世界里也是如此：
<ul>
	<li>分布式系统中的远程调用，一般在本地都会有一个代理。代理除了直接转发客户端的请求，还有额外的操作，比如打开网络链接之类的。</li>
	<li>大文件的缓存也可以代理完成，代理会先检查客户端请求的资源是否缓存，没有缓存则请求资源，再将资源缓存。客户端再次调用时可以直接返回缓存。</li>
	<li>检查权限：将检查权限的逻辑交给代理，权限通过后会代理会访问真实的资源。（在这里我突然想到我的项目也该用这种方式完成，但由于我的项目目前设计的时候只有一个父类，所以可以在父类的构造方法里完成权限检查）</li>
</ul>

</div>

（完）
</body>
</html>
