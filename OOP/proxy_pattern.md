#### 代理模式(proxy_pattern)
编码了这么多，觉得设计模式越发重要，所以再总结下。
wiki上已经总计的很好了：[代理模式](https://en.wikipedia.org/wiki/Proxy_pattern)

##### 基本含义
如图所示，实际上客户端对RealSubject有请求，但是代理模式要求客户端只能请求Proxy对象，Proxy对象再以委派的方式调用RealSubject，RealSubject将结果返回给Proxy对象，Proxy对象再将结果返回给客户端。 为了方便客户端访问，Proxy对象和RealSubject对象保持相同的方法：DoAction()，所以他们都有个共同的接口Subject。 

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/75/Proxy_pattern_diagram.svg/439px-Proxy_pattern_diagram.svg.png">

##### 使用场景

代理模式似乎使得访问流程变得冗余了，但有也有好处：在代理中添加额外的逻辑、功能，使整个系统更好的工作。

比如在现实生活中，如果一个老板非常忙，就会请一个秘书，要找老板的人会先找秘书：秘书可能会直接替老板回答一些问题、回绝一些想见老板的人等等，但当秘书真做不了决定时，他会再去请问老板，老板把答案告诉秘书，秘书再告诉别人。

在这里，我认为秘书就充当了代理。为老板节约了时间，还有一种过滤的作用。

生活中也有不得不使用代理的情况：与外国人交流时，请个翻译。翻译在这里就是充当了代理的角色。

计算的世界里也是如此：

* 分布式系统中的远程调用，一般在本地都会有一个代理。代理除了直接转发客户端的请求，还有额外的操作，比如打开网络链接之类的。
* 大文件的缓存也可以代理完成，代理会先检查客户端请求的资源是否缓存，没有缓存则请求资源，再将资源缓存。客户端再次调用时可以直接返回缓存。* 
* 检查权限：将检查权限的逻辑交给代理，权限通过后会代理会访问真实的资源。（在这里我突然想到我的项目也该用这种方式完成，但由于我的项目目前设计的时候只有一个父类，所以可以在父类的构造方法里完成权限检查）

（完）