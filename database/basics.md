### MySQL的基础知识

*这篇博客将以脱口秀的背稿风格来完成，我相信学到的东西要像别人讲清楚才算真正的学懂了。*

说起MySQL有两个角度可以谈，第一个是运维的角度，也就是从DBA的角度来谈；第二种是开发人员的角度来谈，因为我是一个开发人员，所以我会采用这个角度来谈。

作为一个开发，我觉得关键点有这么几块：MySQL的性能、表的结构设计与优化、索引优化、查询的SQL优化这几块我觉得要重点谈，详细说的；这次不打算重点说的是MySQL基准测试、数据库的监控、分库分表、常见的架构等。其实我也有学过，这是没有而好好准备，用得也比较少。

那么我们先来看看MySQL的性能，我觉得用一个问题来代表这个阐述这个话题更好，那就是什么影响了数据库的性能？
* 首先是服务器硬件， 主要CPU、内存、磁盘IO、网络IO，比如CPU就有两种关键的特性：主频和核心数；目前我们MySQL的版本不提供多个CPU对同一句SQL的处理，所以无法通过多个CPU加快一句SQL的执行速度。如果我们的应用是CPU密集型，那么SQL很复杂的，那么主频要高，比如我在百度做的就属于这种；但如果我们的应用是要求高并发的，那么就是核心数要多，web应用的特点就是高并发，所以如果应对web应用那么CPU核心数比主频更重要。但这个问题我觉得更偏DBA，我不展开说了。需要时再查。
* 其次是服务器的操作系统：有很多配置参数需要调整。这个也不太好举例，我也不展开说的了。
* 第三个是MySQL存储引擎的选择：那这个我觉得是最应该讲清楚的，为了讲清楚这个问题，首先应该说清楚MySQL的体系结构：MySQL最上层是客户端，各种应用，应用链接到MySQL服务器呢，会在MySQL服务器上拥有一个单独线程，所有的查询都会在这个线程内执行，也就是只能用到一个CPU。下一层就是各种MySQL服务层包括：连接管理器，查询解析器、查询缓存、查询优化器、还有内置函数都在这一层，所有跨存储引擎的功能都是在这一层实现的，就是所有存储引擎都有的功能都是在这一层实现的。那么最下面一层就是存储引擎层。存储引擎有很多选择，各有特点，我们要为自己的应用选择合适存储引擎才能达到最好的效果。选存储引擎有一个基本的原则，如果没有特别的需求，就选InnoDB。如果有特殊的需求，比如如果要事务就选InnoDB，如果不需要事务，并且主要是Insert和Select操作，就是只读类应用，比如报表，那可以用MyISAM，如果连Select都很少，主要是Insert，可以选Archive，Archive支持高并发的插入，不支持Update和Delete，而且会压缩数据，极大的节约存储空间，比如要保存日志，使用Archive比较合适。如果需要在线热备方案，只有InnoDB，从崩溃恢复的角度来看，InnoDB支持的最好。需要全文索引：5.7之后选择InnoDB，5.7之前只能使用MyISAM。地理空间的搜索和函数应用，5.7之前只能使用MyISAM 了，5.7之后可以使用InnoDB。最后一点是存储引擎不要混合使用，比如应用不经意间使用了事务，然而操控的表又有InnoDB又有MyISAM，回滚时MyISAM的表是不会回滚的。其它的比如CSV引擎，可以作为中间数据，方便拷贝和转移，等等其它引擎这里就不要详谈了。又因为InnoDB是关键的存储引擎，我再总结一下，首先支持是支持事务，支持事务的方式就是使用了Redo log和Undo log，Redo log为了实现事务的持久性，Undo log是为了实现回滚，主要利用多版本控制。其次是可以使用独立的表空间存储数据，也可以使用系统表空间，这里我们一定要注意调整成独立表空间，独立表空间会为每个表生成以ibd结尾的文件，使用独立表空间可以方便的使用optimize table重建表、索引、释放无用的空间，而且使用独立表空间因为对每个表是单独的一个文件，所以不会遇见磁盘IO的瓶颈。再有InnoDB支持行级锁，在写操作时支持更高的并发，所以InnoDB对update语句支持比较好。InnoDB还支持状态检查：show engine innodb status，可以查看到后台线程信息、事务信息，文件I/O等信息。那么MySQL的存储引擎问题我就说这么多，下面是MySQL数据库参数优化。
* 第四个是MySQL数据库的参数：主要三个方面，内存、IO、安全。在内存方面，首先确定可以使用的内存的上限，不要配的比可用的还大。其次是注意配置每个连接所使用的内存大小，有4个参数指的是每个连接的大小，不是总共的大小。比如sort_buffer_size参数，当连接需要排序时，会立刻申请这个参数大小的内存，如果这个参数过大，那么很容易引发内存崩溃。内存方面还有两个参数特别重要分别是Innodb_buffer_pool_size，这个参数不仅缓存索引，还有数据，还会缓存写入。当主要使用InnoDB表时，这个参数必须足够大，有个简单的公式计算：总内存-(每个线程所需的内存*可能的最大连接数) - 为内存保留的内存。key_buffer_size，这个是MyISAM的索引缓存的大小，因为系统表使用的是MyISAM，所以即使我们不用MyISAM引擎，还是得给这个参数配点内存。其它的参数就不一一说明了。

最后是数据库结构的设计与SQL语句：表设计时一定要考虑到今后需要使用的SQL语句。很多慢查询都是由表设计不合理造成的。有一种说法就是数据库的设计对性能的影响最大。

* 数据库的设计有如下几个步骤：首先需求分析，包括存储需求、数据处理需求、数据安全或者完整性的需求；接着是逻辑设计，关注数据的逻辑存储结构，数据之间的关系。下一步就是物理设计，主要是选择数据库、数据库引擎，进行表结构的设计。最后是维护优化，根据实际情况对索引、存储结构进行优化。
* 对于数据库的结构和设计有一些普世的原则：减少数据冗余，避免数据维护中出现更新、插入、删除的异常，比如更新异常：更改表中某个字段时，需要对多行进行更新；节约储存空间；提高查询效率。
* 在刚刚说的四个步骤中，先说一下逻辑设计阶段，为了设计出没有数据冗余和避免数据异常可以使用数据库设计范式，主要有三条，简单说
	* 第一条：表的字段只有单一属性，表是二维表。
	* 第二条：表只有一个业务主键，如果业务主键是复合主键，那么非主键列不能只依赖部分主键。
	* 第三条：非主属性不能部分依赖，也不能传递依赖主键。举个例子来说，学生表有字段学号、姓名、生日、学院名称、学院电话、学院地址，主键为学号字段，其中学院名称确实依赖学号字段，但学院地址是依赖学院名称的，这里产生了传递依赖，也造成了数据冗余。这个时候我们会把学生表拆分两部分，学生表和学院表。当需要学生的学院信息时，会产生join。
当然并不是说一定要设计出符合范式的表，设计时应参考实际业务需求，比如查询效率需求，因为符合范式设计的表都会产出大量left join，所以还会对表进行一些反范式的设计，反范式设计会经常将经常一起查询的字段放在一张表中，这样还方便建立索引，在理解这些理论基础之后，关键理解设计时需要将范式化和反范式化设计相结合，才能产出实际符合业务需求的表。
* 在物理设计阶段，主要根据逻辑设计的结果来进行的，包括定义数据库、表、字段的命名规范、选择引擎、为字段建立合适的数据类型，最后实际建立。存储引擎刚刚已经说过了。接着就是为字段的选择数据类型，这又是一个重点了，这种选择有一个基本原则：数字优于日期或二进制，最后才考虑字符类型。接着我再说说重点的数据类型，每个数据类型都有自己的特点：比如有5种整数类型，注意选择合适的大小，节约空间、磁盘IO，因为操作系统在读取数据时是以页为单位的，InnoDB每页大小只有16Kb，所以数据的长度越小，加载的数据就越多，相应占用的空间就少。又比如实数类型，注意DECIMAL是精确的，而FLOAT和DOUBLE是非精确的。VARCHAR和CHAR作为最常用的字符串类型，在InnoDB中，varchar是变长，char固定的，两者的单位是字符，不是字节，以UTF8为例，一个字符需要三个字节。varchar的最长长度为65535，因为当varchar存储的字节小于255时，需要额外的一个字节来存储长度，大于255时需要两个来记录长度。比65535再长就需要使用text了。使用varchar的场景主要有两点：字符串最大的长度远大于平均长度时，前一个显然能够极大的节约空间，字符串列很少被更新时都适合用varchar。另一方面呢，char类型是定长的，所以更适合固定长度，比如MD5值、手机号，如果极短的字符串，比如存男、女，那该用char，因为varchar需要额外的一个字节来存储长度，此时varchar用4个，char只用3个，如果字符串经常被更新就应该用char，因为Mysql会一次为char分配足够的内存，不会产生分页之类的情况。

那么再说索引的优化
当数据量比较小时，MySQL可以把数据全装入内存，此时还看不出索引的作用；当数据量过大时，索引才会发挥价值。MySQL是引擎层的东西，所以不同引擎索引有不同的特征。索引有两种类型，最常见的是B-tree索引，利用B+树这种数据结构来完成，因为每个叶子节点都包含下一个节点的指针，所以适合顺序遍历。B-tree索引非常适合范围查找。有以下几种情况会用到B树索引：全值匹配，就是=，比如订单号为order_sn = '123'；接着是匹配最左前缀的查询，比如where order_sn = '123' and order_stat = '20160101'，那么因为order_sn在最左边，还是可以使用到B树索引；其次是匹配列前缀的查询，比如order_sn like '12%'；匹配范围值的查询；除了查询，order by也就是查询也使用到B树索引，等等就不想详细介绍了。有时虽然建立的索引，但是不会使用，比如使用not in和<>、联合索引的时候跳过了索引的列，比如索引是 1,2,3，但是跳过了2，只使用了1和3。索引的另一种类型是Hash索引，InnoDB的 hash索引是自适应hash索引，我们不能手动建立，InnoDB会自动建立。Hash就不如B树索引使用的广泛，比如无法用于排序，还必须是全值匹配，不支持部分查找和范围查找。hash索引基于hash的原理，会有冲突的发生。在重复度很高的列上不能使用hash索引，比如男、女，而在比如身份证这种是比较适合的。
使用索引还要注意一些要点，
* 如不要再索引列上使用函数或表达式
* 又比如InnoDB上需要建立B树索引的列的长度不能超过767个字节，但是我们可以建立前缀索引create index index_name on table(col_name(n));n的取值要尽量使得截取字符尽量不重复，才能提高效率，也可以说是需要截取的字符串选择性尽量高，选择性高是指重复度低，比如身份证号，又比如男女，选择性就差。
* 还有别的要点，由于一次查询只会使用到一个索引，所以在每一列都建立索引这种做法的非常错误的，会浪费写数据的时间，还会在查询时影响MySQL服务层进行索引选择。对于多列的过滤的条件是建立联合索引，但一定要注意索引列的顺序，要尽量将经常使用的列、选择性高的列放在左边、宽度小的列，在联合索引中最左边的列，在只有该列的where语句中的查询也使用到，所以要好好斟酌。
* 另外要尽量使用覆盖索引完成查询，覆盖索引是只在B树中已经有了一个query中所需的全部列了，不用再去读数据行了。典型的例子就是`select count(*) from table`和select count(id) from table`如果在id建立了索引，很显然因为只用读取索引即可满足查询了，这样会加快速度，节约资源，如果需要的列太多或需要的列太长则不适合建立覆盖索引。一个语句是否使用了覆盖索引可以通过explain来查看，如果在extra中出现了Using index则是使用了覆盖索引。
* 双%%加Like是不会使用索引的，尽量避免这样查询语句。
* 正确的使用索引，还在数据更新有，也就是update是有发挥重要的作用，通过索引来找到需要更新的行，就不必锁全部的行了，而没有索引，要进行全表扫描时，会堵塞别的更新的事务。

下面再来说说在索引的维护方面应该注意的事项
* primary key是唯一索引，不用再使用unique key和index了
* 冗余索引有这样的情况Index(a)和index(a,b)，第一个index(a)可以删除了，因为index(a,b)已经为a建立索引的。
* 我们可以使用工具pt-duplicate-key来检查是否有冗余索引。
* 还需要注意那些没有使用的索引，这个我收集了一段sql，查询msyql的系统表，获得所有索引使用的次数。
* 另外，Mysql会根据索引的统计信息来选择使用哪个索引，我们可以使用analyze table table_name来重新生产统计信息。
* 还可以使用optimize table table_name 来减少表和索引的碎片。这个命令要锁表的，一定要小心。

下面谈谈SQL优化
前面说过，设计库表结构和索引时应考虑到编写的SQL，同样编写SQL的时候我们应考虑到已存在的库表结构和索引。想要对SQL进行优化，我们首先要知道有哪些SQL需要被优化，
* 最简单方式就算通过终端用户或测试人员的反馈，我们从打开的页面找到需要的SQL。
* 其次是通过分析慢查日志
* 还可以实时获取存在性能问题的SQL

对于慢查日志，

我们应注意其需要大量磁盘空间，默认MySQL是不打开的记录慢查日志的功能的， 所以需要把slow_query_log设置为ON，另外将long_query_time设置成自己认为合适的时间，这个参数的单位为秒，另一个值得记住的是log_queries_not_using_indexes打开这个参数可以记录没有使用索引的query语句。对产生的慢查日志，可以使用mysqldumpslow工具来分析。另一个更好的工具是pt-query-digest，它除了语句的统计以外还能有顺便生成语句的执行计划，那么就能更方便的分析了。


除了慢查日志可以获得慢的SQL以外，也能实时的获得有性能问题的SQL，最方便的办法就是对information_schema中的PROCESSLIST表，表TIME就代表当前sql执行的时间，当然还有user,host,query这些信息，那么结合shell脚本，很简单就能做一个实时监控系统。

找到慢的SQL，我们下一步就是要搞清楚为什么会慢。那这里就得简单梳理一下一个query执行的过程，这一段我学习的时候发现，发现不太好讲，简单说一下过程，客户端发送SQL到服务器，这一段几乎问题比较少，接着是服务器检查是否缓存了该SQL，如果缓存了就直接返回结果，如果没有缓存服务器酒会进行SQL解析、预处理、再优化一下，最后生成执行计划，最后根据执行计划来调用存储引擎的API完成数据的查询，再把数据返回过去。细节非常多，比如说缓存，MySQL是将query弄成一个的hash值来形成缓存的key，query必须每一个字节都一样才能拿到缓存的值，对缓存控制可以通过设置query_cache_type来完成，除了一般的ON、OFF、DEMAND，如果设置成DEMAND，可以在SQL中加入SQL_NO_CACHE或sql_cache来控制。对于读写频繁的表，或者说修改频繁的表，不要使用缓存。其它细节就不一一叙述了。

对执行计划有个初步了解之后，就需要对度量特定SQL的每个阶段消耗的时间。1是使用profile，先set profiling=1;再show profiles 显示总时间。最后使用show profile for query N，N就是show profiles显示ID，来查看特定query每个阶段的时间。profile也算是比较老的办法了，还有更好的办法在5.6和5.7可以使用performance_schema的办法，使用时首先要执行两句SQL开启，再执行一句SQL查询指定想要查看的线程ID，这可以看到某个线程上的sql不同阶段执行的时间了。

上面所说的都是特定特定分析，但是还是有一些对于特定SQL优化的经典办法：大表数据的修改使用分批次，一共要改100万行，那么就分一次改5000行，这样事务执行的时间短，也给主从复制留下了空余时间。再有大表结构要改，可以采用建新表，再将老表数据导入新表，再建立触发器同步，最后改表名的方法要快的多，避免结构修改时的表锁情况，使用一个工具也能完成这件事。另外用left join代替not in或者不等于，这很常见了。预设一些汇总表，比如商品的购买数，可以提前算好昨天之前的，今天的再实时统计，再两个加起来就好了。等等。



#### 参考
* 打造扛得住的MySQL数据库架构

